import qrcode from "qrcode-generator";
import Colors from "../constants/Colors";
import { Wallet, Utils } from "xpring-common-js";
// import { RippleAPI } from "ripple-lib";
import * as s from "sologenic-xrpl-stream-js-non-redis";

export const countWords = words => {
  const arrayOfWords = words
    .trim()
    .split(" ")
    .filter(item => item.lenght !== 0);
  return arrayOfWords.length === 12 ? true : false;
};

export const generateQRCode = data => {
  const typeNumber = 4;
  const errorCorrectionLevel = "L";
  const QRCode = qrcode(typeNumber, errorCorrectionLevel);
  QRCode.addData(data);
  QRCode.make();
  const uri = QRCode.createDataURL(2, 4);
  return uri;
};

export const genereateRandomNumbers = () => {
  const randoms = [];
  for (let i = 0; i < 3; i += 1) {
    while (true) {
      const tmp = Math.floor(Math.random() * 12) + 1;
      if (!randoms.includes(tmp)) {
        randoms.push(tmp);
        break;
      }
    }
  }
  return randoms;
};

export const getPriceChange = (tickerLast, tickerOpen) => {
  return tickerLast - tickerOpen === 0
    ? "0%"
    : `${(((tickerLast - tickerOpen) / tickerOpen) * 100).toFixed(2)}%`;
};

export const getPriceColor = priceChange => {
  return priceChange.substring(0, 1) === "-"
    ? Colors.errorBackground
    : Colors.freshGreen;
};

export const createSevensObj = arr => {
  let sevensObj = {};
  arr.map(item => {
    sevensObj[item.market] = item.seven;
  });
  return sevensObj;
};

// Generate a random wallet.
export const generateNewRandomWallet = () => {
  const result = Wallet.generateRandomWallet();
  return result;
};

// Generate a mnemonic array
export const generateMnemonicArray = input => {
  const result = input.trim().split(" ");
  return result;
};

// Get an address from generated random wallet
export const getAddress = input => {
  const wallet = input.wallet;
  const address = wallet.getAddress();
  return address;
};

// Get wallet from mnemonic
export const getWalletFromMnemonic = mnemonic => {
  const wallet = Wallet.generateWalletFromMnemonic(mnemonic);
  return wallet;
};

// Encode an X-Address
export const getXAddressFromRippleClassicAddress = (
  rippleClassicAddress,
  tag,
) => {
  const xAddress = Utils.encodeXAddress(rippleClassicAddress, tag);
  return xAddress;
};

//Decode an X-Address
export const getRippleClassicAddressFromXAddress = xAddress => {
  const classicAddress = Utils.decodeXAddress(xAddress);
  return classicAddress.address;
};

//Validate ripple address or not
//bitcoin address returns false
export const isValidRippleAddress = address => {
  return address ? Utils.isValidAddress(address) : false;
};

//Validate ripple XAddress or not
//XAddress only returns true
export const isValidXAddress = address => {
  return address ? Utils.isValidXAddress(address) : false;
};

//Validate ripple classic address,'r' is the first letter, or not
//classic address only returns true
export const isValidClassicAddress = address => {
  return address ? Utils.isValidClassicAddress(address) : false;
};

export const sologenic = new s.SologenicTxHandler(
  // RippleAPI Options
  {
    server: "wss://testnet.xrpl-labs.com", // Kudos to Wietse Wind
  },
  // Sologenic Options, hash or redis
  {
    queueType: "hash",
    hash: {},
  },
);

export const isValidSecret = secret => {
  const rippleApi = sologenic.getRippleApi();
  return secret ? rippleApi.isValidSecret(secret) : false;
};

// export const rippleApi = new RippleAPI({
//   server: "wss://s.altnet.rippletest.net:51233"
// });

export const rippleApi = sologenic.getRippleApi();

export const getAccountInfo = address => {
  return rippleApi.getAccountInfo(address);
};

export const setAccount = (address, secret, keypair) => {
  return sologenic.setAccount({
    address,
    secret: secret ? secret : "",
    keypair: keypair ? keypair : "",
  });
};

export const transferSolo = (issuer, account, destination, value) => {
  const valueSendMax = value + 1;
  const valueAmount = value;
  const solo = "534F4C4F00000000000000000000000000000000";

  return sologenic.submit({
    TransactionType: "Payment",
    Account: account,
    Destination: destination,
    SendMax: {
      currency: solo,
      issuer: "rEFgkRo5BTxXJiLVYMdEnQQ9J9Kj1F3Yvi",
      value: `${valueSendMax}`,
    },
    Amount: {
      currency: solo,
      issuer: "rEFgkRo5BTxXJiLVYMdEnQQ9J9Kj1F3Yvi",
      value: `${valueAmount}`,
    },
  });
};
// Create a trustline linking the account (a certain address) with issuer
export const createTrustline = account => {
  const solo = "534F4C4F00000000000000000000000000000000";
  return sologenic.submit({
    TransactionType: "TrustSet",
    Account: account,
    LimitAmount: {
      currency: solo,
      issuer: "rEFgkRo5BTxXJiLVYMdEnQQ9J9Kj1F3Yvi", //this is a test issuer for solo which is generated by sologenic-issuarance
      value: "400000000",
    },
    Flags: 0x00020000,
  });
};

export const transferXrp = (account, destination, value) => {
  const valueAmount = value / 0.000001;

  return sologenic.submit({
    TransactionType: "Payment",
    Account: account,
    Destination: destination,
    Amount: `${valueAmount}`,
  });
};

export const formatWalletTotalBalance = number => {
  return parseFloat(number)
    .toFixed(2)
    .toString()
    .replace(/\B(?=(\d{3})+(?!\d))/g, ",");
};

export const extractSeparatorFromText = text => {
  if (typeof text === "undefined") {
    return "";
  }

  if (typeof text !== "string") {
    text = String(text);
  }

  return text.replace(/,/g, "");
};

export const checkWalletExists = (walletAddress, wallets) => {
  let walletAlreadyExists = false;
  wallets.forEach(item => {
    if (item.walletAddress === walletAddress) {
      walletAlreadyExists = true;
    }
  });
  return walletAlreadyExists;
};

export const checkMnemoicExists = (mnemonic, wallets) => {
  let walletAlreadyExists = false;
  wallets.forEach(item => {
    console.log(mnemonic);
    if (
      item.details &&
      item.details.mnemonic &&
      item.details.mnemonic === mnemonic
    ) {
      walletAlreadyExists = true;
    }
  });
  return walletAlreadyExists;
};

export const filterTransactions = (transactions, currentLedger) => {
  let xrpTransactions = [];
  let soloTransactions = [];
  transactions.filter(item => {
    if (item.type === "payment" && item.outcome.result === "tesSUCCESS") {
      // console.log("confirmations ", currentLedger - item.outcome.ledgerVersion);
      if (
        item.outcome.deliveredAmount.currency ===
        "534F4C4F00000000000000000000000000000000"
      ) {
        soloTransactions.push({
          ...item,
          outcome: {
            ...item.outcome,
            ledgerVersion: currentLedger - item.outcome.ledgerVersion,
          },
        });
      } else {
        xrpTransactions.push({
          ...item,
          outcome: {
            ...item.outcome,
            ledgerVersion: currentLedger - item.outcome.ledgerVersion,
          },
        });
      }
    } else {
      if (item.outcome.result === "tecUNFUNDED_PAYMENT") {
        // console.log(item.specification.source.maxAmount);
        if (
          item.specification.source.maxAmount.currency ===
          "534F4C4F00000000000000000000000000000000"
        ) {
          soloTransactions.push({
            ...item,
            outcome: {
              ...item.outcome,
              ledgerVersion: currentLedger - item.outcome.ledgerVersion,
            },
          });
        } else if (item.specification.source.maxAmount.currency === "XRP") {
          xrpTransactions.push({
            ...item,
            outcome: {
              ...item.outcome,
              ledgerVersion: currentLedger - item.outcome.ledgerVersion,
            },
          });
        }
      }
    }
  });
  return {
    xrpTransactions,
    soloTransactions,
  };
};
